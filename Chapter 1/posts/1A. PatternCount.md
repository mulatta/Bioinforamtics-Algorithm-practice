# 1A. 단어 세기
## 개요
앞서 단백질의 특이성(specificity)에 대해 이야기하였다. 세포 내에서 일어나는 이러한 단백질의 특이성은 마치 단백질에 눈이 달린 것 처럼 작동한다고 생각하기 쉽지만, 단백질의 특이성 또한 결국 물리화학적 법칙을 따르는 분자의 운동에 불과하다.

즉, 단백질 분자가 외부 계의 물리적 힘 - 특히 열 - 에 의해 진동하거나 부유하는 brownian motion을 통해 돌아다니다가, 적절한 DNA 서열과 유효충돌이 일어나야 상호작용이 일어나는 것이다. 

따라서, 우리는 다음과 같은 가설을 세울 수 있다. 
> **1. DnaA box가 많을수록 DnaA protein과의 유효충돌 횟수가 커진다.**

> **2. DnaA box가 많이 존재한다면, 이 서열들 중 일부에 변이가 일어나도 결합을 방해하는 데에 미치는 영향을 줄일 수 있다.**

그러므로, 위 가설에 따르면 문제는 반복되는 특정 서열을 찾는 것으로 귀결된다.
하지만 여전히 우리는 이 *특정 서열* 의 길이가 어느정도인지 알지 못하기 때문에, 임의의 길이를 가지는 특정 서열을 k-mer로 정의한다.

 ***k-mer***: 길이가 k인 문자열

## Problem
- Input: 전체 문자열 Text, Text에서 찾으려는 문자열 Pattern
- Output: Text에서 등장하는 Pattern의 횟수
- function: Pattern $\to$ count

## Pseudo-code
```
PatternCount(Text, Pattern)
    count <- 0
    for i <- 0 to |Text| - |Pattern|
        if Text(i, |Pattern|) == Pattern
            count <-- count + 1
    return count
```

## Evaluation
### Time Complexity
 이 알고리즘의 경우 Brute-force[^1] 방식으로, 모든 경우의 수를 순차적[^2]으로 확인한다.
- line[1]: Pattern이 등장하는 횟수를 저장할 변수 선언[^3] $\to O(1)$
- line[2]: Text와 Pattern의 입력 크기를 각각 |Text|, |Pattern|이라 할 때, Text 문자열에서 Pattern 길이의 부분 문자열(substring)을 형성할 수 있는 모든 시작점은 0번째부터 |Text|-|Pattern|번째까지 이다. $\to O(n-m)$
- line[3]: 현재 순번에서 가능한 부분 문자열 형성 - Text(i, |Pattern|)만큼을 slicing 해오는 연산 $\to$ O(1)
- line[4]: sliced substring과 Pattern의 비교 연산 $\to$ O(1)
- line[5]: count 변수의 산술 연산 $\to$ O(1)
---
- line[3] ~ line[5]의 경우 상수항의 시간이 소요된다.
- Worst case: $n >> m \to n-m \approx n$ (for |Text| = n, |Pattern| = m)

***Total Time Complexity***: $O(1) + O(n-m) \times (O(1)+O(1)+O(1)) \approxeq O(n)$


## [Implementation](/Bioinforamtics-Algorithm-practice/Chapter%201/codes/PatternCount.py)
```python
# 전체 Text에서 주어진 Pattern의 등장 횟수를 반환하는 함수
def PatternCount(text, pattern):
    
    # 결과로 반환할 변수 선언
    count = 0

    # pattern의 시작점이 될 수 있는 영역을 모두 순회
    for idx in range(len(text) - len(pattern) + 1):
        
        # 현재 인덱스를 시작으로 하는 pattern이 입력 pattern과 같다면 count
        if(text[idx:idx + len(pattern)] == pattern):
            count += 1
            
    return count
```

---
[^1]: 가능한 모든 경우의 수를 탐색하는 알고리즘 기법을 의미함  
[^2]: 순차 탐색 - 순차적으로 탐색하는 기법  
[^3]: 대입 연산
<div align="left">
    <a href="./Introduction.md">← Chapter 1. Introduction</a>
</div>

<div align="right">
    <a href="./1B. FrequentWords.md">1B. 빈번한 단어 문제 →</a>
</div>
